/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */


export interface paths {
  "/v0/webhooks": {
    /** Returns all webhooks. */
    get: operations["getWebhooks"];
    /** Creates a webhook. */
    post: operations["createWebhook"];
    options: {
      responses: {
        200: components["responses"]["200-NoContent"];
      };
    };
  };
  "/v0/webhooks/{webhookID}": {
    /**
     * Returns given Webhook.
     * @description Query a webhook by its ID.
     */
    get: operations["getWebhook"];
    /** Edits a webhook. */
    put: operations["editWebhook"];
    /** Deletes a webhook. */
    delete: operations["deleteWebhook"];
  };
  "/v0/addresses/{address}/transactions": {
    /** Returns an enriched transaction history for a given address */
    get: operations["getEnrichedTransactions"];
  };
  "/v0/addresses/{address}/raw-transactions": {
    /** Returns raw transaction history for a given address */
    get: operations["getRawTransactionHistory"];
  };
  "/v0/transactions": {
    /** Returns an array of enriched, human-readable versions of the given transactions. */
    post: operations["getEnrichedTransaction"];
    options: {
      responses: {
        200: components["responses"]["200-NoContent"];
      };
    };
  };
  "/v0/raw-transactions": {
    /** Returns an array of raw (directly from RPC) transactions. */
    post: operations["getRawTransactions"];
    options: {
      responses: {
        200: components["responses"]["200-NoContent"];
      };
    };
  };
  "/v0/addresses/{address}/balances": {
    /** Returns the native balance and token balances for a given address. */
    get: operations["getBalances"];
  };
  "/v0/token-metadata": {
    /** Returns all metadata associated with an account, including data from the old token list. */
    post: operations["queryMetadataV1"];
    options: {
      responses: {
        200: components["responses"]["200-NoContent"];
      };
    };
  };
}

export type webhooks = Record<string, never>;

export interface components {
  schemas: {
    Webhook: {
      webhookID?: string;
      wallet?: string;
      webhookURL?: string;
      transactionTypes?: components["schemas"]["TransactionType"][];
      accountAddresses?: string[];
      webhookType?: string;
      authHeader?: string;
    };
    /** @enum {string} */
    TransactionType: "UNKNOWN" | "NFT_BID" | "NFT_GLOBAL_BID" | "NFT_GLOBAL_BID_CANCELLED" | "NFT_BID_CANCELLED" | "NFT_LISTING" | "NFT_CANCEL_LISTING" | "NFT_SALE" | "NFT_MINT" | "NFT_AUCTION_CREATED" | "NFT_AUCTION_UPDATED" | "NFT_AUCTION_CANCELLED" | "NFT_PARTICIPATION_REWARD" | "NFT_MINT_REJECTED" | "CREATE_STORE" | "WHITELIST_CREATOR" | "ADD_TO_WHITELIST" | "REMOVE_FROM_WHITELIST" | "AUCTION_MANAGER_CLAIM_BID" | "EMPTY_PAYMENT_ACCOUNT" | "UPDATE_PRIMARY_SALE_METADATA" | "ADD_TOKEN_TO_VAULT" | "ACTIVATE_VAULT" | "INIT_VAULT" | "INIT_BANK" | "INIT_STAKE" | "MERGE_STAKE" | "SPLIT_STAKE" | "SET_BANK_FLAGS" | "SET_VAULT_LOCK" | "UPDATE_VAULT_OWNER" | "UPDATE_BANK_MANAGER" | "RECORD_RARITY_POINTS" | "ADD_RARITIES_TO_BANK" | "INIT_FARM" | "INIT_FARMER" | "REFRESH_FARMER" | "UPDATE_FARM" | "AUTHORIZE_FUNDER" | "DEAUTHORIZE_FUNDER" | "FUND_REWARD" | "CANCEL_REWARD" | "LOCK_REWARD" | "PAYOUT" | "VALIDATE_SAFETY_DEPOSIT_BOX_V2" | "SET_AUTHORITY" | "INIT_AUCTION_MANAGER_V2" | "UPDATE_EXTERNAL_PRICE_ACCOUNT" | "AUCTION_HOUSE_CREATE" | "CLOSE_ESCROW_ACCOUNT" | "WITHDRAW" | "DEPOSIT" | "TRANSFER" | "BURN" | "BURN_NFT" | "PLATFORM_FEE" | "LOAN" | "RESCIND_LOAN" | "OFFER_LOAN" | "CANCEL_OFFER" | "LEND_FOR_NFT" | "REQUEST_LOAN" | "CANCEL_LOAN_REQUEST" | "BORROW_SOL_FOR_NFT" | "CLAIM_NFT" | "REBORROW_SOL_FOR_NFT" | "REPAY_LOAN" | "TAKE_LOAN" | "FORECLOSE_LOAN" | "UPDATE_OFFER" | "ADD_TO_POOL" | "REMOVE_FROM_POOL" | "CLOSE_POSITION" | "UNLABELED" | "CLOSE_ACCOUNT" | "WITHDRAW_GEM" | "DEPOSIT_GEM" | "STAKE_TOKEN" | "UNSTAKE_TOKEN" | "STAKE_SOL" | "UNSTAKE_SOL" | "CLAIM_REWARDS" | "BUY_SUBSCRIPTION" | "SWAP" | "INIT_SWAP" | "CANCEL_SWAP" | "REJECT_SWAP" | "INITIALIZE_ACCOUNT" | "TOKEN_MINT" | "CREATE_APPRAISAL" | "CANDY_MACHINE_WRAP" | "CANDY_MACHINE_UNWRAP" | "CANDY_MACHINE_UPDATE" | "CANDY_MACHINE_ROUTE" | "FRACTIONALIZE" | "DEPOSIT_FRACTIONAL_POOL" | "FUSE" | "CREATE_RAFFLE" | "BUY_TICKETS" | "UPDATE_ITEM" | "LIST_ITEM" | "DELIST_ITEM" | "ADD_ITEM" | "CLOSE_ITEM" | "BUY_ITEM" | "FILL_ORDER" | "UPDATE_ORDER" | "CREATE_ORDER" | "CLOSE_ORDER" | "CANCEL_ORDER" | "KICK_ITEM" | "UPGRADE_FOX" | "UPGRADE_FOX_REQUEST" | "LOAN_FOX" | "BORROW_FOX" | "SWITCH_FOX_REQUEST" | "SWITCH_FOX" | "CREATE_ESCROW" | "ACCEPT_REQUEST_ARTIST" | "CANCEL_ESCROW" | "ACCEPT_ESCROW_ARTIST" | "ACCEPT_ESCROW_USER" | "PLACE_BET" | "PLACE_SOL_BET" | "CREATE_BET" | "INIT_RENT" | "NFT_RENT_LISTING" | "NFT_RENT_CANCEL_LISTING" | "NFT_RENT_UPDATE_LISTING" | "NFT_RENT_ACTIVATE" | "NFT_RENT_END" | "UPGRADE_PROGRAM_INSTRUCTION" | "FINALIZE_PROGRAM_INSTRUCTION" | "EXECUTE_TRANSACTION" | "APPROVE_TRANSACTION" | "ACTIVATE_TRANSACTION" | "CREATE_TRANSACTION" | "CANCEL_TRANSACTION" | "REJECT_TRANSACTION" | "ADD_INSTRUCTION" | "CREATE_MASTER_EDITION" | "ATTACH_METADATA" | "REQUEST_PNFT_MIGRATION" | "START_PNFT_MIGRATION" | "MIGRATE_TO_PNFT" | "UPDATE_RAFFLE" | "CREATE_MERKLE_TREE" | "DELEGATE_MERKLE_TREE" | "COMPRESSED_NFT_MINT" | "COMPRESSED_NFT_TRANSFER" | "COMPRESSED_NFT_REDEEM" | "COMPRESSED_NFT_CANCEL_REDEEM" | "COMPRESSED_NFT_BURN" | "COMPRESSED_NFT_VERIFY_CREATOR" | "COMPRESSED_NFT_UNVERIFY_CREATOR" | "COMPRESSED_NFT_VERIFY_COLLECTION" | "COMPRESSED_NFT_UNVERIFY_COLLECTION" | "COMPRESSED_NFT_SET_VERIFY_COLLECTION" | "DECOMPRESS_NFT" | "COMPRESS_NFT" | "COMPRESSED_NFT_DELEGATE" | "CREATE_POOL" | "DISTRIBUTE_COMPRESSION_REWARDS" | "CHANGE_COMIC_STATE" | "UPDATE_RECORD_AUTHORITY_DATA" | "CREATE_AVATAR_CLASS" | "CREATE_AVATAR" | "CREATE_TRAIT" | "CREATE_PAYMENT_METHOD" | "EQUIP_TRAIT" | "EQUIP_TRAIT_AUTHORITY" | "REMOVE_TRAIT" | "REMOVE_TRAIT_AUTHORITY" | "UPDATE_TRAIT_VARIANT" | "UPDATE_TRAIT_VARIANT_AUTHORITY" | "UPDATE_CLASS_VARIANT_AUTHORITY" | "UPDATE_TRAIT_VARIANT_METADATA" | "UPDATE_CLASS_VARIANT_METADATA" | "BEGIN_VARIANT_UPDATE" | "BEGIN_TRAIT_UPDATE" | "CANCEL_UPDATE" | "UPDATE_VARIANT" | "TRANSFER_PAYMENT" | "BURN_PAYMENT" | "BURN_PAYMENT_TREE" | "TRANSFER_PAYMENT_TREE" | "ADD_PAYMENT_MINT_PAYMENT_METHOD" | "ADD_TRAIT_CONFLICTS" | "VERIFY_PAYMENT_MINT" | "VERIFY_PAYMENT_MINT_TEST" | "BOUND_HADO_MARKET_TO_FRAKT_MARKET" | "DEPOSIT_TO_BOND_OFFER_STANDARD" | "WITHDRAW_FROM_BOND_OFFER_STANDARD" | "INITIALIZE_HADO_MARKET" | "FINISH_HADO_MARKET" | "UPDATE_HADO_MARKET_FEE" | "REMOVE_BOND_OFFER_V2" | "REPAY_FBOND_TO_TRADE_TRANSACTIONS" | "EXIT_VALIDATE_AND_SELL_TO_BOND_OFFERS_V2" | "REFINANCE_TO_BOND_OFFERS_V2" | "CREATE_BOND_AND_SELL_TO_OFFERS" | "LIQUIDATE_BOND_ON_AUCTION_PNFT" | "CLAIM_NFT_BY_LENDER_PNFT" | "CREATE_BOND_AND_SELL_TO_OFFERS_FOR_TEST" | "INITIALIZE_FLASH_LOAN_POOL" | "DEPOSIT_SOL_TO_FLASH_LOAN_POOL" | "WITHDRAW_SOL_FROM_FLASH_LOAN_POOL" | "TAKE_FLASH_LOAN" | "REPAY_FLASH_LOAN" | "CREATE_BOND_OFFER_STANDARD" | "UPDATE_BOND_OFFER_STANDARD" | "STAKE_BANX" | "UNSTAKE_BANX" | "UNSUB_OR_HARVEST_WEEKS" | "UNSUB_OR_HARVEST_WEEKS_ENHANCED" | "UPDATE_STAKING_SETTINGS" | "MAP_BANX_TO_POINTS" | "PATCH_BROKEN_USER_STAKES" | "DEPOSIT_TO_REWARDS_VAULT" | "WITHDRAW_REWARDS_FROM_VAULT" | "REFINANCE_FBOND_BY_LENDER" | "SELL_STAKED_BANX_TO_OFFERS" | "REPAY_STAKED_BANX" | "CREATE_PERPETUAL_BOND_OFFER" | "REMOVE_PERPETUAL_OFFER" | "REPAY_PERPETUAL_LOAN" | "REFINANCE_PERPETUAL_LOAN" | "CREATE_BOND_AND_SELL_TO_OFFERS_CNFT" | "REPAY_FBOND_TO_TRADE_TRANSACTIONS_CNFT" | "REFINANCE_TO_BOND_OFFERS_V2_CNFT" | "CLAIM_NFT_BY_LENDER_CNFT" | "LIQUIDATE_BOND_ON_AUCTION_CNFT" | "MAKE_PERPETUAL_MARKET" | "UPDATE_PERPETUAL_MARKET" | "UPDATE_PERPETUAL_OFFER" | "UPDATE_INTEREST_PERPETUAL_MARKET" | "BORROW_PERPETUAL" | "CLAIM_PERPETUAL_LOAN" | "TERMINATE_PERPETUAL_LOAN" | "INSTANT_REFINANCE_PERPETUAL_LOAN" | "BORROW_STAKED_BANX_PERPETUAL" | "REPAY_STAKED_BANX_PERPETUAL_LOAN" | "BORROW_CNFT_PERPETUAL" | "REPAY_CNFT_PERPETUAL_LOAN" | "CLAIM_CNFT_PERPETUAL_LOAN" | "REPAY_PARTIAL_PERPETUAL_LOAN" | "CREATE_COLLECTION" | "UPDATE_COLLECTION" | "UPDATE_COLLECTION_OR_CREATOR" | "UPDATE_FLOOR" | "DELETE_COLLECTION" | "CREATE_STATS" | "UPDATE_STATS" | "CLEAN" | "EXPIRE" | "FIX_POOL" | "ADMIN_SYNC_LIQUIDITY" | "CLOSE_POOL" | "UPDATE_POOL" | "UPDATE_POOL_COLLECTIONS" | "UPDATE_POOL_STATUS" | "UPDATE_POOL_MORTGAGE" | "UPDATE_USABLE_AMOUNT" | "UPDATE_POOL_WHITELIST" | "ADD_LIQUIDITY" | "SYNC_LIQUIDITY" | "WITHDRAW_LIQUIDITY" | "TAKE_COMPRESSED_LOAN" | "REPAY" | "REPAY_COMPRESSED" | "LIQUIDATE" | "TAKE_MORTGAGE" | "FREEZE" | "UNFREEZE" | "SELL_LOAN" | "BUY_LOAN" | "EXTEND_LOAN" | "SELL_NFT" | "PROPOSE_LOAN" | "CANCEL_PROPOSAL" | "POOL_CANCEL_PROPOSAL" | "ACCEPT_PROPOSAL" | "EXECUTE_LOAN" | "EXECUTE_MORTGAGE" | "LIST_NFT" | "DELIST_NFT" | "CLAIM_SALE" | "BOT_LIQUIDATE" | "BOT_UNFREEZE" | "BOT_LIQUIDATE_SELL" | "BOT_DELIST" | "BOT_CLAIM_SALE";
    /** @enum {string} */
    NFTEventType: "NFT_BID" | "NFT_BID_CANCELLED" | "NFT_GLOBAL_BID" | "NFT_GLOBAL_BID_CANCELLED" | "NFT_LISTING" | "NFT_CANCEL_LISTING" | "NFT_SALE" | "NFT_MINT" | "NFT_MINT_REJECTED" | "NFT_AUCTION_CREATED" | "NFT_AUCTION_UPDATED" | "NFT_AUCTION_CANCELLED" | "NFT_PARTICIPATION_REWARD" | "BURN_NFT" | "NFT_RENT_LISTING" | "NFT_RENT_CANCEL_LISTING" | "NFT_RENT_UPDATE_LISTING" | "NFT_RENT_ACTIVATE" | "NFT_RENT_END" | "ATTACH_METADATA" | "MIGRATE_TO_PNFT" | "CREATE_POOL";
    /** @enum {string} */
    CompressedNFTEventType: "COMPRESSED_NFT_MINT" | "COMPRESSED_NFT_TRANSFER" | "CREATE_MERKLE_TREE" | "COMPRESSED_NFT_REDEEM" | "COMPRESSED_NFT_CANCEL_REDEEM" | "COMPRESSED_NFT_BURN" | "COMPRESSED_NFT_DELEGATE" | "DELEGATE_MERKLE_TREE" | "COMPRESSED_NFT_VERIFY_CREATOR" | "COMPRESSED_NFT_UNVERIFY_CREATOR" | "COMPRESSED_NFT_VERIFY_COLLECTION" | "COMPRESSED_NFT_UNVERIFY_COLLECTION" | "COMPRESSED_NFT_SET_VERIFY_COLLECTION" | "DECOMPRESS_NFT" | "COMPRESS_NFT";
    /** @enum {string} */
    TransactionSource: "FORM_FUNCTION" | "EXCHANGE_ART" | "CANDY_MACHINE_V3" | "CANDY_MACHINE_V2" | "CANDY_MACHINE_V1" | "UNKNOWN" | "SOLANART" | "SOLSEA" | "MAGIC_EDEN" | "HOLAPLEX" | "METAPLEX" | "OPENSEA" | "SOLANA_PROGRAM_LIBRARY" | "ANCHOR" | "PHANTOM" | "SYSTEM_PROGRAM" | "STAKE_PROGRAM" | "COINBASE" | "CORAL_CUBE" | "HEDGE" | "LAUNCH_MY_NFT" | "GEM_BANK" | "GEM_FARM" | "DEGODS" | "BSL" | "YAWWW" | "ATADIA" | "DIGITAL_EYES" | "HYPERSPACE" | "TENSOR" | "BIFROST" | "JUPITER" | "MERCURIAL" | "SABER" | "SERUM" | "STEP_FINANCE" | "CROPPER" | "RAYDIUM" | "ALDRIN" | "CREMA" | "LIFINITY" | "CYKURA" | "ORCA" | "MARINADE" | "STEPN" | "SENCHA" | "SAROS" | "ENGLISH_AUCTION" | "FOXY" | "HADESWAP" | "FOXY_STAKING" | "FOXY_RAFFLE" | "FOXY_TOKEN_MARKET" | "FOXY_MISSIONS" | "FOXY_MARMALADE" | "FOXY_COINFLIP" | "FOXY_AUCTION" | "CITRUS" | "ZETA" | "ELIXIR" | "ELIXIR_LAUNCHPAD" | "CARDINAL_RENT" | "CARDINAL_STAKING" | "BPF_LOADER" | "BPF_UPGRADEABLE_LOADER" | "SQUADS" | "SHARKY_FI" | "OPEN_CREATOR_PROTOCOL" | "BUBBLEGUM" | "NOVA" | "D_READER" | "RAINDROPS" | "W_SOL" | "DUST" | "SOLI" | "USDC" | "FLWR" | "HDG" | "MEAN" | "UXD" | "SHDW" | "POLIS" | "ATLAS" | "USH" | "TRTLS" | "RUNNER" | "INVICTUS";
    /** @enum {string} */
    SaleType: "AUCTION" | "INSTANT_SALE" | "OFFER" | "GLOBAL_OFFER" | "MINT" | "UNKNOWN";
    Token: {
      /**
       * @description The mint account of the token.
       * @example DsfCsbbPH77p6yeLS1i4ag9UA5gP9xWSvdCx72FJjLsx
       */
      mint?: string;
      tokenStandard?: components["schemas"]["TokenStandard"];
    };
    /** @enum {string} */
    TokenStandard: "NonFungible" | "FungibleAsset" | "Fungible" | "NonFungibleEdition";
    TokenTransfer: {
      /** @description The user account the tokens are sent from. */
      fromUserAccount?: string;
      /** @description The user account the tokens are sent to. */
      toUserAccount?: string;
      /** @description The token account the tokens are sent from. */
      fromTokenAccount?: string;
      /** @description The token account the tokens are sent to. */
      toTokenAccount?: string;
      /** @description The number of tokens sent. */
      tokenAmount?: number;
      /**
       * @description The mint account of the token.
       * @example DsfCsbbPH77p6yeLS1i4ag9UA5gP9xWSvdCx72FJjLsx
       */
      mint?: string;
    };
    NativeTransfer: {
      /** @description The user account the sol is sent from. */
      fromUserAccount?: string;
      /** @description The user account the sol is sent to. */
      toUserAccount?: string;
      /** @description The amount of sol sent (in lamports). */
      amount?: number;
    };
    /** @description Metaplex metadata stored both on-chain and off-chain. */
    TokenMetadataResponse: {
      mint?: string;
      onChainData?: components["schemas"]["OnChainMetadata"];
      offChainData?: components["schemas"]["OffChainMetadata"];
    };
    /** @description Metaplex metadata that is stored on-chain. */
    OnChainMetadata: {
      key?: string;
      mint?: string;
      updateAuthority?: string;
      data?: {
        name?: string;
        symbol?: string;
        uri?: string;
        sellerFeeBasisPoints?: number;
        creators?: {
            address?: string;
            share?: string;
            verified?: boolean;
          }[];
      };
      tokenStandard?: string;
      primarySaleHappened?: boolean;
      isMutable?: boolean;
      editionNonce?: number;
      collection?: {
        key?: string;
        verified?: boolean;
      };
      collectionDetails?: {
        size?: number;
      };
      uses?: {
        useMethod?: string;
        remaining?: number;
        total?: number;
      };
    };
    /** @description Metaplex metadata that is stored off-chain. */
    OffChainMetadata: {
      name?: string;
      symbol?: string;
      attributes?: {
          traitType?: string;
          value?: string;
        }[];
      sellerFeeBasisPoints?: number;
      image?: string;
      properties?: {
        category?: string;
        files?: {
            uri?: string;
            type?: string;
          }[];
        creators?: {
            address?: string;
            share?: string;
          }[];
      };
    };
    RawTransaction: {
      slot?: number;
      blocktime?: number;
      transaction?: components["schemas"]["InnerTransaction"];
      meta?: components["schemas"]["Meta"];
    };
    InnerTransaction: {
      signatures?: string[];
      message?: {
        accountKeys?: string[];
        header?: Record<string, never>;
        recentBlockhash?: string;
        instructions?: {
            programIdIndex?: number;
            accounts?: number[];
            data?: string;
          }[];
      };
    };
    Meta: {
      err?: Record<string, never>;
      fee?: number;
      preBalances?: number[];
      postBalances?: number[];
      preTokenBalances?: number[];
      postTokenBalances?: number[];
      logMessages?: string[];
      rewards?: Record<string, never>[];
      loadedAddresses?: Record<string, never>;
    };
    EnrichedTransaction: {
      /** @example Human readable interpretation of the transaction */
      description?: string;
      type?: components["schemas"]["TransactionType"];
      source?: components["schemas"]["TransactionSource"];
      /** @example 5000 */
      fee?: number;
      /** @example 8cRrU1NzNpjL3k2BwjW3VixAcX6VFc29KHr4KZg8cs2Y */
      feePayer?: string;
      /** @example yy5BT9benHhx8fGCvhcAfTtLEHAtRJ3hRTzVL16bdrTCWm63t2vapfrZQZLJC3RcuagekaXjSs2zUGQvbcto8DK */
      signature?: string;
      /** @example 148277128 */
      slot?: number;
      /** @example 1656442333 */
      timestamp?: number;
      nativeTransfers?: components["schemas"]["NativeTransfer"][];
      tokenTransfers?: components["schemas"]["TokenTransfer"][];
      accountData?: components["schemas"]["AccountData"][];
      transactionError?: {
        error?: string;
      };
      instructions?: components["schemas"]["Instruction"][];
      /** @description Events associated with this transaction. These provide fine-grained information about the transaction. They match the types returned from the event APIs. */
      events?: {
        nft?: components["schemas"]["NFTEvent"];
        swap?: components["schemas"]["SwapEvent"];
        compressed?: components["schemas"]["CompressedNFTEvent"];
        distributeCompressionRewards?: components["schemas"]["DistributeCompressionRewardsEvent"];
        setAuthority?: components["schemas"]["SetAuthorityEvent"];
      };
    };
    /** @description Individual instruction data in a transaction. */
    Instruction: {
      /** @description The accounts used in instruction. */
      accounts?: string[];
      /**
       * @description Data passed into the instruction
       * @example kdL8HQJrbbvQRGXmoadaja1Qvs
       */
      data?: string;
      /**
       * @description Program used in instruction
       * @example MEisE1HzehtrDpAAT8PnLHjpSSkRYakotTuJRPjTpo8
       */
      programId?: string;
      /** @description Inner instructions used in instruction */
      innerInstructions?: components["schemas"]["InnerInstruction"][];
    };
    /** @description Inner instructions for each instruction */
    InnerInstruction: {
      accounts?: string[];
      data?: string;
      programId?: string;
    };
    /** @description Sol and token transfers involving the account are referenced in this object. */
    AccountData: {
      /** @description The account that this data is provided for. */
      account?: string;
      /** @description Native (SOL) balance change of the account. */
      nativeBalanceChange?: number;
      /** @description Token balance changes of the account. */
      tokenBalanceChanges?: components["schemas"]["TokenBalanceChange"][];
    };
    NFTEvent: {
      /** @description Human readable interpretation of the transaction */
      description?: string;
      type?: components["schemas"]["NFTEventType"];
      source?: components["schemas"]["TransactionSource"];
      /**
       * @description The amount of the NFT transaction (in lamports).
       * @example 1000000
       */
      amount?: number;
      /** @example 5000 */
      fee?: number;
      /** @example 8cRrU1NzNpjL3k2BwjW3VixAcX6VFc29KHr4KZg8cs2Y */
      feePayer?: string;
      /** @example 4jzQxVTaJ4Fe4Fct9y1aaT9hmVyEjpCqE2bL8JMnuLZbzHZwaL4kZZvNEZ6bEj6fGmiAdCPjmNQHCf8v994PAgDf */
      signature?: string;
      /** @example 148277128 */
      slot?: number;
      /** @example 1656442333 */
      timestamp?: number;
      saleType?: components["schemas"]["SaleType"];
      /** @description The buyer of the NFT. */
      buyer?: string;
      /** @description The seller of the NFT. */
      seller?: string;
      /** @description The staker of the NFT. */
      staker?: string;
      /** @description NFTs that are a part of this NFT event. */
      nfts?: components["schemas"]["Token"][];
    };
    CompressedNFTEvent: {
      type?: components["schemas"]["CompressedNFTEventType"];
      /** @description The address of the related merkle tree. */
      treeId?: string;
      /** @description The id of the compressed nft. */
      assetId?: string;
      /** @description The index of the leaf being appended or modified. */
      leafIndex?: number;
      /** @description The index of the parsed instruction in the transaction. */
      instructionIndex?: number;
      /** @description The index of the parsed inner instruction in the transaction. */
      innerInstructionIndex?: number;
      /** @description The new owner of the leaf. */
      newLeafOwner?: string;
      /** @description The previous owner of the leaf. */
      oldLeafOwner?: string;
    };
    DistributeCompressionRewardsEvent: {
      /** @description Amount transfered in the DistributeCompressionRewardsV0 instruction. */
      amount?: number;
    };
    SetAuthorityEvent: {
      /** @description Tthe account whose authority is changing. */
      account?: string;
      /** @description Current authority. */
      from?: string;
      /** @description New authority. */
      to?: string;
      /** @description The index of the parsed instruction in the transaction. */
      instructionIndex?: number;
      /** @description The index of the parsed inner instruction in the transaction. */
      innerInstructionIndex?: number;
    };
    SwapEvent: {
      /** @description The native input to the swap in Lamports. */
      nativeInput?: components["schemas"]["NativeBalanceChange"];
      /** @description The native output of the swap in Lamports. */
      nativeOutput?: components["schemas"]["NativeBalanceChange"];
      /** @description The token inputs to the swap. */
      tokenInputs?: components["schemas"]["TokenBalanceChange"][];
      /** @description The token outputs of the swap. */
      tokenOutputs?: components["schemas"]["TokenBalanceChange"][];
      /** @description The token fees paid by an account. */
      tokenFees?: components["schemas"]["TokenBalanceChange"][];
      /** @description The native fees paid by an account. */
      nativeFees?: components["schemas"]["NativeBalanceChange"][];
      /** @description The inner swaps occuring to make this swap happen. Eg. a swap of wSOL <-> USDC may be make of multiple swaps from wSOL <-> DUST, DUST <-> USDC */
      innerSwaps?: components["schemas"]["TokenSwap"][];
    };
    TokenSwap: {
      /** @description The token inputs of this swap. */
      tokenInputs?: components["schemas"]["TokenTransfer"][];
      /** @description The token outputs of this swap. */
      tokenOutputs?: components["schemas"]["TokenTransfer"][];
      /** @description Fees charged with tokens for this swap. */
      tokenFees?: components["schemas"]["TokenTransfer"][];
      /** @description Fees charged in SOL for this swap. */
      nativeFees?: components["schemas"]["NativeTransfer"][];
      /** @description Information about the program creating this swap. */
      programInfo?: components["schemas"]["ProgramInfo"];
    };
    ProgramInfo: {
      /** @example ORCA */
      source?: string;
      /**
       * @description The account of the program
       * @example whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc
       */
      account?: string;
      /**
       * @description The name of the program
       * @example ORCA_WHIRLPOOLS
       */
      programName?: string;
      /**
       * @description The name of the instruction creating this swap. It is the value of instruction name from the Anchor IDL, if it is available.
       * @example whirlpoolSwap
       */
      instructionName?: string;
    };
    NativeBalanceChange: {
      /**
       * @description The account the native balance change is for
       * @example 2uySTNgvGT2kwqpfgLiSgeBLR3wQyye1i1A2iQWoPiFr
       */
      account?: string;
      /**
       * @description The amount of the balance change as a string
       * @example 100000000
       */
      amount?: string;
    };
    TokenBalanceChange: {
      /** @example F54ZGuxyb2gA7vRjzWKLWEMQqCfJxDY1whtqtjdq4CJ */
      userAccount?: string;
      /** @example 2kvmbRybhrcptDnwyNv6oiFGFEnRVv7MvVyqsxkirgdn */
      tokenAccount?: string;
      /** @example DUSTawucrTsGU8hcqRdHDCbuYhCPADMLM2VcCb8VnFnQ */
      mint?: string;
      rawTokenAmount?: components["schemas"]["RawTokenAmount"];
    };
    RawTokenAmount: {
      tokenAmount?: string;
      decimals?: number;
    };
    NamesResponse: {
      domainNames?: string[];
    };
    BalancesResponse: {
      tokens?: components["schemas"]["Balance"][];
      /** @description In Lamports */
      nativeBalance?: number;
    };
    Balance: {
      mint?: string;
      amount?: number;
      decimals?: number;
      tokenAccount?: string;
    };
    NFTsResponse: {
      numberOfPages?: number;
      nfts?: components["schemas"]["Asset"][];
    };
    Asset: {
      name?: string;
      tokenAddress?: string;
      collectionAddress?: string;
      collectionName?: string;
      imageURL?: string;
      traits?: {
          trait_type?: string;
          value?: string;
        }[];
    };
    /** @enum {string} */
    Commitment: "finalized" | "confirmed";
    TokensMetadataRequest: {
      mintAccounts?: string[];
    };
    ParseTransactionsRequest: {
      transactions?: string[];
    };
    CreateWebhookRequest: {
      webhookURL?: string;
      transactionTypes?: components["schemas"]["TransactionType"][];
      accountAddresses?: string[];
      accountAddressOwners?: string[];
      webhookType?: string;
      authHeader?: string;
      encoding?: string;
      txnStatus?: string;
    };
    RpcProxyRequest: {
      /**
       * @description Name of the method to be invoked
       * @example getBlock
       */
      method?: string;
      /** @description Params to be passed. Please see Solana JSON-RPC docs. */
      params?: (string | number | boolean | unknown[] | Record<string, never>)[];
    };
    QueryNftEventsRequest: {
      query?: {
        accounts?: string[];
        types?: components["schemas"]["NFTEventType"][];
        sources?: components["schemas"]["TransactionSource"][];
        /**
         * @description Earliest slot to include in the query (inclusive). Cannot be combined with "startTime".
         * @example 162368570
         */
        startSlot?: number;
        /**
         * @description Latest slot to include in the query (inclusive). Cannot be combined with "endTime".
         * @example 162368580
         */
        endSlot?: number;
        /**
         * @description Earliest event time (unix seconds). Cannot be combined with "startSlot".
         * @example 1669055189
         */
        startTime?: number;
        /**
         * @description Latest event time (unix seconds). Cannot be combined with "endSlot".
         * @example 1669070189
         */
        endTime?: number;
        nftCollectionFilters?: {
          firstVerifiedCreator?: components["schemas"]["FirstVerifiedCreator"][];
          verifiedCollectionAddress?: components["schemas"]["VerifiedCollectionAddress"][];
        };
      };
      options?: {
        /**
         * @description Maximum number of items to return. Must be between 1 and 1000. Default is 100.
         * @default 100
         */
        limit?: number;
        sortOrder?: components["schemas"]["SortOrder"];
        paginationToken?: components["schemas"]["PaginationToken"];
      };
    };
    QueryNftEventsResponse: {
      result?: components["schemas"]["NftEventV2"][];
      paginationToken?: components["schemas"]["PaginationToken"];
    };
    DescribeNftsRequest: {
      mints?: components["schemas"]["NftMintAccount"][];
    };
    DescribeNftsResponse: {
        mint?: components["schemas"]["NftMintAccount"];
        name?: components["schemas"]["NftName"];
        burned?: components["schemas"]["NftBurned"];
        firstVerifiedCreator?: components["schemas"]["FirstVerifiedCreator"];
        verifiedCollectionAddress?: components["schemas"]["VerifiedCollectionAddress"];
        activeListings?: components["schemas"]["ActiveListing"][];
      }[];
    ActiveListingsRequest: {
      query?: {
        marketplaces?: unknown;
        firstVerifiedCreators?: components["schemas"]["FirstVerifiedCreator"][];
        verifiedCollectionAddresses?: components["schemas"]["VerifiedCollectionAddress"][];
      };
      options?: {
        /**
         * @description Maximum number of items to return. Must be between 1 and 1000. Default is 100.
         * @default 100
         */
        limit?: number;
        paginationToken?: components["schemas"]["PaginationToken"];
      };
    };
    ActiveListingsResponse: {
      result?: {
          mint?: components["schemas"]["NftMintAccount"];
          name?: components["schemas"]["NftName"];
          firstVerifiedCreator?: components["schemas"]["FirstVerifiedCreator"];
          verifiedCollectionAddress?: components["schemas"]["VerifiedCollectionAddress"];
          activeListings?: components["schemas"]["ActiveListing"][];
        }[];
      paginationToken?: components["schemas"]["PaginationToken"];
    };
    /**
     * @description Order of the returned results. Must be 'ASC' or 'DESC'. Results are descending by default.
     * @default DESC
     * @enum {string}
     */
    SortOrder: "ASC" | "DESC";
    NftV2: {
      mint?: components["schemas"]["NftMintAccount"];
      name?: components["schemas"]["NftName"];
      burned?: components["schemas"]["NftBurned"];
      firstVerifiedCreator?: components["schemas"]["FirstVerifiedCreator"];
      verifiedCollectionAddress?: components["schemas"]["VerifiedCollectionAddress"];
    };
    /**
     * @description NFT mint account address.
     * @example KG6f4Fa6YxAW8cG2Dhb18DiMn3rQ3rSLa1Eo2FYM4gi
     */
    NftMintAccount: string;
    /**
     * @description The name of the NFT.
     * @example y00t #2940
     */
    NftName: string;
    /**
     * @description If the NFT was was burned. Burned NFTs have no name, firstVerifiedCreator, or verifiedCollectionAddress.
     * @example false
     */
    NftBurned: boolean;
    /**
     * @description First verified creator of the NFT. Used to reference NFT collections.
     * @example A4FM6h8T5Fmh9z2g3fKUrKfZn6BNFEgByR8QGpdbQhk1
     */
    FirstVerifiedCreator: string;
    /**
     * @description Verified Metaplex collection address. Does not exist for all NFT collections.
     * @example 4mKSoDDqApmF1DqXvVTSL6tu2zixrSSNjqMxUnwvVzy2
     */
    VerifiedCollectionAddress: string;
    ActiveListing: {
      /**
       * @description Signature of the listing transaction.
       * @example 27W41DrnxGFJGX7yEGuKBtRb7oMwFdGdPwffBTTeakV8nTQTgWR2hzFKmrt8QnxaMEbw4pS2NoiLmiuB2VfqxVn7
       */
      transactionSignature?: string;
      marketplace?: components["schemas"]["Marketplace"];
      /**
       * @description Listed price of the NFT (in lamports).
       * @example 1000000
       */
      amount?: number;
      /**
       * @description Address of the NFT seller.
       * @example 3ngLS7Y64DoMAHJ6k6XYh8vo5nSiG66AP1yLvbckfKrc
       */
      seller?: string;
    };
    /**
     * @description Marketplace where the NFT is being listed.
     * @example MAGIC_EDEN
     * @enum {string}
     */
    Marketplace: "MAGIC_EDEN" | "OPENSEA" | "FORM_FUNCTION" | "EXCHANGE_ART" | "SOLANART" | "SOLSEA" | "HOLAPLEX" | "CORAL_CUBE" | "YAWWW" | "SOLPORT" | "HYPERSPACE" | "DIGITAL_EYES" | "UNKNOWN";
    /**
     * @description Token used for pagination. Provide the token to the API to retrieve the results from the next page. If no token exists, the query has no results remaining.
     * @example V1_162262948_99
     */
    PaginationToken: string;
    RawTransactionsV1Request: {
      query?: {
        accounts?: string[];
        /**
         * @description Earliest slot to include in the query (inclusive). Cannot be combined with "startTime".
         * @example 162368570
         */
        startSlot?: number;
        /**
         * @description Latest slot to include in the query (inclusive). Cannot be combined with "endTime".
         * @example 162368580
         */
        endSlot?: number;
        /**
         * @description Earliest event time (unix seconds). Cannot be combined with "startSlot".
         * @example 1669055189
         */
        startTime?: number;
        /**
         * @description Latest event time (unix seconds). Cannot be combined with "endSlot".
         * @example 1669070189
         */
        endTime?: number;
      };
      options?: {
        /**
         * @description Maximum number of items to return. Must be between 1 and 500. Default is 100.
         * @default 100
         */
        limit?: number;
        sortOrder?: components["schemas"]["SortOrder"];
        paginationToken?: components["schemas"]["PaginationToken"];
      };
    };
    RawTransactionsV1Response: {
      result?: components["schemas"]["RawTransaction"][];
      paginationToken?: components["schemas"]["PaginationToken"];
    };
    TokensMetadataRequestV1: {
      mintAccounts?: string[];
      /**
       * @description Include offchain data referenced in the uri of the metadata account. Omitting defaults to false.
       * @default false
       */
      includeOffChain?: boolean;
      /**
       * @description Disable usage of cache, useful for monitoring metadata changes.
       * @default false
       */
      disableCache?: boolean;
    };
    TokensMetadataResponseV1: {
        account?: string;
        onChainAccountInfo?: components["schemas"]["OnChainAccountInfoResult"];
        onChainMetadata?: components["schemas"]["OnChainMetadataResult"];
        offChainMetadata?: components["schemas"]["OffChainMetadataResult"];
        legacyMetadata?: components["schemas"]["LegacyMetadata"];
      }[];
    OnChainAccountInfoResult: {
      accountInfo?: components["schemas"]["OnChainAccountInfo"];
      error?: components["schemas"]["AccountErrorType"];
    };
    OnChainMetadataResult: {
      metadata?: components["schemas"]["OnChainMetadata"];
      error?: components["schemas"]["AccountErrorType"];
    };
    OffChainMetadataResult: {
      metadata?: components["schemas"]["OffChainMetadata"];
      uri?: string;
      error?: components["schemas"]["AccountErrorType"];
    };
    /** @description Account data that is stored on-chain. */
    OnChainAccountInfo: {
      key?: string;
      isSigner?: boolean;
      isWritable?: boolean;
      lamports?: number;
      data?: {
        parsed?: {
          info?: {
            decimals?: number;
            freezeAuthority?: string;
            isInitialized?: boolean;
            mintAuthority?: string;
            supply?: string;
          };
          type?: string;
        };
        program?: string;
        space?: number;
      };
      owner?: string;
      executable?: boolean;
      rentEpoch?: number;
    };
    /** @description Data from the old SPL token list. */
    LegacyMetadata: {
      chainId?: number;
      address?: string;
      symbol?: string;
      name?: string;
      decimals?: number;
      logoURI?: string;
      tags?: string[];
      extensions?: Record<string, never>;
    };
    /**
     * @example
     * @enum {string}
     */
    AccountErrorType: "UNKNOWN" | "EMPTY_ACCOUNT" | "TIMEOUT" | "INVALID_ACCOUNT" | "INVALID_PUBKEY";
  };
  responses: {
    /** @description No content. */
    "200-NoContent": {
      content: never;
    };
    /** @description Invalid request. */
    "400-BadRequest": {
      content: {
        "application/json": {
          error?: string;
        };
      };
    };
    /** @description Unauthorized request. */
    "401-Unauthorized": {
      content: {
        "application/json": {
          error?: string;
        };
      };
    };
    /** @description Request was forbidden. */
    "403-Forbidden": {
      content: {
        "application/json": {
          error?: string;
        };
      };
    };
    /** @description The specified resource was not found. */
    "404-NotFound": {
      content: {
        "application/json": {
          error?: string;
        };
      };
    };
    /** @description Exceeded rate limit. */
    "429-TooManyRequests": {
      content: {
        "application/json": {
          error?: string;
        };
      };
    };
    /** @description The server encountered an unexpected condition that prevented it from fulfilling the request. */
    "500-InternalServerError": {
      content: {
        "application/json": {
          error?: string;
        };
      };
    };
  };
  parameters: {
    /** @description The api key. */
    apiKeyParam: string;
    /** @description Maximum number of items to return. */
    limitParam?: number;
    /** @description Start searching backwards from this transaction signature. */
    beforeParam?: string;
    /** @description Search until this transaction signature. */
    untilParam?: string;
    /** @description How finalized a block must be to be included in the search. If not provided, will default to "finalized" commitment. Note that "processed" level commitment is not supported. */
    commitmentParam?: components["schemas"]["Commitment"];
    /** @description The address to query for. */
    addressParam: string;
    /** @description The webhook ID. */
    webhookIDParam: string;
    /** @description The page number used for pagination. */
    pageNumberParam?: number;
    /** @description The signature of the transaction you wish to query for. */
    transactionIdParam: string;
    /** @description The TransactionSource to filter by. For a list of possible options, see the Transaction Types section. */
    transactionSourceParam?: components["schemas"]["TransactionSource"];
    /** @description The TransactionType to filter by. For a list of possible options, see the Transaction Types section. */
    transactionTypeParam?: components["schemas"]["TransactionType"];
  };
  requestBodies: never;
  headers: never;
  pathItems: never;
}

export type $defs = Record<string, never>;

export type external = Record<string, never>;

export interface operations {

  /** Returns all webhooks. */
  getWebhooks: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
      };
    };
    responses: {
      /** @description Webhooks for the given API key. */
      200: {
        content: {
          "application/json": components["schemas"]["Webhook"][];
        };
      };
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
  /** Creates a webhook. */
  createWebhook: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateWebhookRequest"];
      };
    };
    responses: {
      /** @description The created webhook. */
      200: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
    };
  };
  /**
   * Returns given Webhook.
   * @description Query a webhook by its ID.
   */
  getWebhook: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
      };
      path: {
        webhookID: components["parameters"]["webhookIDParam"];
      };
    };
    responses: {
      /** @description Returns details about the given webhook ID. */
      200: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
    };
  };
  /** Edits a webhook. */
  editWebhook: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
      };
      path: {
        webhookID: components["parameters"]["webhookIDParam"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["CreateWebhookRequest"];
      };
    };
    responses: {
      /** @description The edited webhook. */
      200: {
        content: {
          "application/json": components["schemas"]["Webhook"];
        };
      };
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
  /** Deletes a webhook. */
  deleteWebhook: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
      };
      path: {
        webhookID: components["parameters"]["webhookIDParam"];
      };
    };
    responses: {
      200: components["responses"]["200-NoContent"];
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
  /** Returns an enriched transaction history for a given address */
  getEnrichedTransactions: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
        before?: components["parameters"]["beforeParam"];
        until?: components["parameters"]["untilParam"];
        commitment?: components["parameters"]["commitmentParam"];
        source?: components["parameters"]["transactionSourceParam"];
        type?: components["parameters"]["transactionTypeParam"];
      };
      path: {
        address: components["parameters"]["addressParam"];
      };
    };
    responses: {
      /** @description Returns an array of enriched transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["EnrichedTransaction"][];
        };
      };
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
  /** Returns raw transaction history for a given address */
  getRawTransactionHistory: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
        before?: components["parameters"]["beforeParam"];
        until?: components["parameters"]["untilParam"];
        commitment?: components["parameters"]["commitmentParam"];
      };
      path: {
        address: components["parameters"]["addressParam"];
      };
    };
    responses: {
      /** @description Returns an array of raw transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["RawTransaction"][];
        };
      };
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
  /** Returns an array of enriched, human-readable versions of the given transactions. */
  getEnrichedTransaction: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
        commitment?: components["parameters"]["commitmentParam"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ParseTransactionsRequest"];
      };
    };
    responses: {
      /** @description Returns an array of enriched transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["EnrichedTransaction"][];
        };
      };
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
  /** Returns an array of raw (directly from RPC) transactions. */
  getRawTransactions: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
        commitment?: components["parameters"]["commitmentParam"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["ParseTransactionsRequest"];
      };
    };
    responses: {
      /** @description Returns an array of raw transactions. */
      200: {
        content: {
          "application/json": components["schemas"]["RawTransaction"][];
        };
      };
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
  /** Returns the native balance and token balances for a given address. */
  getBalances: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
      };
      path: {
        address: components["parameters"]["addressParam"];
      };
    };
    responses: {
      /** @description Returns the native balance and the token balances for a given account. */
      200: {
        content: {
          "application/json": components["schemas"]["BalancesResponse"];
        };
      };
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
  /** Returns all metadata associated with an account, including data from the old token list. */
  queryMetadataV1: {
    parameters: {
      query: {
        "api-key": components["parameters"]["apiKeyParam"];
      };
    };
    requestBody: {
      content: {
        "application/json": components["schemas"]["TokensMetadataRequestV1"];
      };
    };
    responses: {
      /** @description Query result. */
      200: {
        content: {
          "application/json": components["schemas"]["TokensMetadataResponseV1"];
        };
      };
      400: components["responses"]["400-BadRequest"];
      401: components["responses"]["401-Unauthorized"];
      403: components["responses"]["403-Forbidden"];
      404: components["responses"]["404-NotFound"];
      429: components["responses"]["429-TooManyRequests"];
      500: components["responses"]["500-InternalServerError"];
    };
  };
}
