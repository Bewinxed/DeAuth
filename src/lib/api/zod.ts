import { z } from 'zod';

export const schema = z.object({"app/orgs":z.object({"GET":z.object({"parameters":z.object({"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional(),"name":z.string().optional(),"owner_id":z.string().optional(),"callback_urls":z.array(z.string()).optional(),"created_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional(),"branding_id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"POST":z.object({"parameters":z.object({"body":z.object({"id":z.string().optional(),"name":z.string().optional(),"callback_urls":z.union([z.object({}),z.array(z.string())]).optional(),"created_at":z.union([z.string().datetime(),z.string()]).optional(),"updated_at":z.union([z.string().datetime(),z.string()]).optional(),"modified_by_user_id":z.string().optional(),"members":z.object({}).optional(),"applications":z.object({}).optional(),"subscription":z.object({}).optional(),"branding":z.object({}).optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional(),"name":z.string().optional(),"owner_id":z.string().optional(),"callback_urls":z.array(z.string()).optional(),"created_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional(),"branding_id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing user id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"DELETE":z.object({"parameters":z.object({"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"body":z.object({"id":z.union([z.object({}),z.string()]).optional(),"name":z.union([z.object({}),z.string()]).optional(),"callback_urls":z.union([z.array(z.string()),z.object({"push":z.union([z.array(z.string()),z.string()]).optional()})]).optional(),"created_at":z.union([z.object({}),z.string().datetime(),z.string()]).optional(),"updated_at":z.union([z.object({}),z.string().datetime(),z.string()]).optional(),"modified_by_user_id":z.union([z.object({}),z.string()]).optional(),"owner":z.object({}).optional(),"members":z.object({}).optional(),"applications":z.object({}).optional(),"subscription":z.object({}).optional(),"branding":z.object({}).optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"api/auth/auth_requests":z.object({"GET":z.object({"parameters":z.object({"query":z.object({"id":z.string().optional(),"state":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"uuid":z.string().optional(),"state":z.string().optional(),"nonce":z.string().optional(),"uri":z.string().optional(),"signature":z.string().optional(),"provider_access_token":z.string().optional(),"provider_refresh_token":z.string().optional(),"provider_account_id":z.string().optional(),"access_token":z.string().optional(),"refresh_token":z.string().optional(),"access_token_expires_in":z.number().optional(),"user_id":z.string().optional(),"created_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional(),"application_id":z.string().optional(),"ip_address":z.string().optional(),"auth_method":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing query params").optional()}).optional(),"404":z.object({"message":z.literal("Auth request not found").optional()}).optional()}).optional()}).optional()}).optional(),"api/auth/authorize":z.object({"GET":z.object({"parameters":z.record(z.any()).optional(),"responses":z.object({}).optional()}).optional()}).optional(),"api/auth/session":z.object({"GET":z.object({"parameters":z.object({"query":z.object({"session_id":z.string().optional(),"session":z.string().optional(),"signature":z.string().optional(),"proof":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.string().optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing session id").optional()}).optional(),"401":z.union([z.object({"message":z.literal("No access token").optional()}),z.object({"message":z.literal("Session expired").optional()})]).optional(),"404":z.union([z.object({"message":z.literal("Session not found").optional()}),z.object({"message":z.literal("Auth request not found").optional()}),z.object({"message":z.literal("User not found").optional()}),z.object({"message":z.literal("Session not found").optional()})]).optional()}).optional()}).optional()}).optional(),"api/login/discord":z.object({"GET":z.object({"parameters":z.record(z.any()).optional(),"responses":z.object({"200":z.string().optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing app_id").optional()}).optional()}).optional()}).optional()}).optional(),"api/login/solana":z.object({"GET":z.object({"parameters":z.record(z.any()).optional(),"responses":z.object({"200":z.string().optional()}).optional()}).optional()}).optional(),"api/nfts/:public_key":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"public_key":z.string().optional()}).optional(),"query":z.object({"after":z.string().optional(),"before":z.string().optional(),"limit":z.string().optional(),"page":z.string().optional(),"sortBy":z.object({"sortBy":z.any().optional(),"sortDirection":z.any().optional()}).optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"grand_total":z.boolean().optional(),"total":z.number().optional(),"limit":z.number().optional(),"page":z.number().optional(),"items":z.array(z.object({"interface":z.enum(["Custom","Executable","FungibleAsset","Identity","Legacy_NFT","ProgrammableNFT","V1_NFT","V1_PRINT","V2_NFT"]).optional(),"id":z.string().optional(),"content":z.object({"$schema":z.string().optional(),"json_uri":z.string().optional(),"files":z.array(z.object({"uri":z.string().optional(),"mime":z.string().optional(),"cdn_uri":z.string().optional(),"quality":z.object({"schema":z.string().optional()}).optional(),"contexts":z.array(z.enum(["app","app-desktop","app-mobile","vr","wallet-default","web-desktop","web-mobile"])).optional()})).optional(),"metadata":z.object({"attributes":z.array(z.object({"value":z.string().optional(),"trait_type":z.string().optional()})).optional(),"description":z.string().optional(),"name":z.string().optional(),"symbol":z.string().optional()}).optional(),"links":z.object({"external_url":z.string().optional(),"image":z.string().optional(),"animation_url":z.string().optional()}).optional()}).optional(),"authorities":z.array(z.object({"address":z.string().optional(),"scopes":z.array(z.enum(["extension","full","metadata","royalty"])).optional()})).optional(),"compression":z.object({"eligible":z.boolean().optional(),"compressed":z.boolean().optional(),"data_hash":z.string().optional(),"creator_hash":z.string().optional(),"asset_hash":z.string().optional(),"tree":z.string().optional(),"seq":z.number().optional(),"leaf_id":z.number().optional()}).optional(),"grouping":z.array(z.object({"group_key":z.string().optional(),"group_value":z.string().optional(),"verified":z.boolean().optional(),"collection_metadata":z.object({"name":z.string().optional(),"symbol":z.string().optional(),"image":z.string().optional(),"description":z.string().optional(),"external_url":z.string().optional()}).optional()})).optional(),"royalty":z.object({"royalty_model":z.enum(["creators","fanout","single"]).optional(),"target":z.string().optional(),"percent":z.number().optional(),"basis_points":z.number().optional(),"primary_sale_happened":z.boolean().optional()}).optional(),"ownership":z.object({"frozen":z.boolean().optional(),"delegated":z.boolean().optional(),"delegate":z.string().optional(),"ownership_model":z.enum(["single","token"]).optional(),"owner":z.string().optional()}).optional(),"creators":z.array(z.object({"address":z.string().optional(),"share":z.number().optional(),"verified":z.boolean().optional()})).optional(),"uses":z.object({"use_method":z.enum(["Burn","Multiple","Single"]).optional(),"remaining":z.number().optional(),"total":z.number().optional()}).optional(),"supply":z.object({"print_max_supply":z.number().optional(),"print_current_supply":z.number().optional(),"edition_nonce":z.number().optional()}).optional(),"mutable":z.boolean().optional(),"burnt":z.boolean().optional()})).optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"api/user/:user_id":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"user_id":z.string().optional()}).optional(),"query":z.object({"by":z.enum(["account_id","userId"]).optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"key":z.array(z.object({"id":z.string().optional(),"hashed_password":z.string().optional(),"user_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"account_id":z.string().optional(),"additional_data":z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])])),z.record(z.union([z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.union([z.record(z.literal("...")),z.record(z.union([z.literal("..."),z.never()])).superRefine((value, ctx) => {
for (const key in value) {
let evaluated = false
if (key.match(new RegExp("^[0-9]+$"))) {
evaluated = true
const result = z.literal("...").safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: Key matching regex /${key}/ must match schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
if (!evaluated) {
const result = z.never().safeParse(value[key])
if (!result.success) {
ctx.addIssue({
          path: [...ctx.path, key],
          code: 'custom',
          message: `Invalid input: must match catchall schema`,
          params: {
            issues: result.error.issues
          }
        })
}
}
}
}),z.union([z.string(),z.number(),z.boolean()])]).optional()})).optional(),"id":z.string().optional(),"name":z.string().optional(),"username":z.string().optional(),"avatar_url":z.string().optional(),"email":z.string().optional(),"joined_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"path":z.object({"user_id":z.string().optional()}).optional(),"body":z.object({"id":z.union([z.object({}),z.string()]).optional(),"name":z.union([z.object({}),z.string()]).optional(),"username":z.union([z.object({}),z.string()]).optional(),"avatar_url":z.union([z.object({}),z.string()]).optional(),"email":z.union([z.object({}),z.string()]).optional(),"joined_at":z.union([z.object({}),z.string().datetime(),z.string()]).optional(),"updated_at":z.union([z.object({}),z.string().datetime(),z.string()]).optional(),"organization":z.object({}).optional(),"nfts":z.object({}).optional(),"session":z.object({}).optional(),"key":z.object({}).optional(),"auth_request":z.object({}).optional(),"app_role_assignment":z.object({}).optional(),"user_role":z.object({}).optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional(),"name":z.string().optional(),"username":z.string().optional(),"avatar_url":z.string().optional(),"email":z.string().optional(),"joined_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"api/auth/callback/:provider":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"provider":z.string().optional()}).optional()}).optional(),"responses":z.object({"302":z.null().optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Invalid provider").optional()}).optional(),"401":z.union([z.object({"message":z.literal("No User Id").optional()}),z.object({"message":z.literal("You have been denied access to this application, Contact the application owner if you believe this is an error.").optional()})]).optional(),"404":z.object({"message":z.literal("Session not found").optional()}).optional()}).optional()}).optional()}).optional(),"api/login/discord/callback":z.object({"GET":z.object({"parameters":z.object({"query":z.object({"state":z.any().optional(),"code":z.any().optional()}).optional()}).optional(),"responses":z.object({"400":z.null().optional()}).optional(),"errors":z.object({"400":z.union([z.object({"message":z.literal("Invalid state").optional()}),z.object({"message":z.literal("No auth request found").optional()})]).optional(),"404":z.object({"message":z.literal("Application not found").optional()}).optional(),"500":z.object({"message":z.literal("User not found nor created").optional()}).optional()}).optional()}).optional()}).optional(),"api/siws/message/verify":z.object({"POST":z.object({"parameters":z.object({"body":z.object({"input":z.object({"domain":z.string().optional(),"address":z.string().optional(),"statement":z.string().optional(),"uri":z.string().optional(),"version":z.string().optional(),"chainId":z.string().optional(),"nonce":z.string().optional(),"issuedAt":z.string().optional(),"expirationTime":z.string().optional(),"notBefore":z.string().optional(),"requestId":z.string().optional(),"resources":z.array(z.string()).optional()}).optional(),"output":z.object({"signedMessage":z.string().optional(),"signature":z.string().optional(),"account":z.object({"publicKey":z.string().optional(),"address":z.string().optional(),"chains":z.array(z.string()).optional(),"features":z.array(z.string()).optional(),"label":z.string().optional(),"icon":z.string().optional()}).optional(),"signatureType":z.enum(["ed25519","legacy"]).optional()}).optional()}).optional(),"query":z.object({"state":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"user":z.object({"userId":z.string().optional(),"id":z.string().optional(),"avatar_url":z.string().optional(),"public_keys":z.array(z.string()).optional()}).optional(),"sessionId":z.string().optional(),"activePeriodExpiresAt":z.string().datetime().optional(),"idlePeriodExpiresAt":z.string().datetime().optional(),"state":z.enum(["active","idle"]).optional(),"fresh":z.boolean().optional(),"public_key":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing state").optional()}).optional(),"404":z.object({"message":z.literal("Application not found").optional()}).optional(),"500":z.object({"message":z.literal("User not found nor created").optional()}).optional()}).optional()}).optional()}).optional(),"app/orgs/:org_id/apps":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional(),"org_id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional(),"name":z.string().optional(),"description":z.string().optional(),"organization_id":z.string().optional(),"access_token_secret":z.string().optional(),"refresh_token_secret":z.string().optional(),"access_token_expiry":z.number().optional(),"refresh_token_expiry":z.number().optional(),"created_at":z.string().datetime().optional(),"branding_id":z.number().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"POST":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional()}).optional(),"body":z.object({"name":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional(),"name":z.string().optional(),"description":z.string().optional(),"organization_id":z.string().optional(),"access_token_secret":z.string().optional(),"refresh_token_secret":z.string().optional(),"access_token_expiry":z.number().optional(),"refresh_token_expiry":z.number().optional(),"created_at":z.string().datetime().optional(),"branding_id":z.number().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"DELETE":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional(),"org_id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional()}).optional(),"body":z.object({"id":z.union([z.object({}),z.string()]).optional(),"name":z.union([z.object({}),z.string()]).optional(),"description":z.union([z.object({}),z.string()]).optional(),"access_token_secret":z.union([z.object({}),z.string()]).optional(),"refresh_token_secret":z.union([z.object({}),z.string()]).optional(),"access_token_expiry":z.union([z.object({"increment":z.number().optional(),"decrement":z.number().optional(),"multiply":z.number().optional(),"divide":z.number().optional()}),z.number()]).optional(),"refresh_token_expiry":z.union([z.object({"increment":z.number().optional(),"decrement":z.number().optional(),"multiply":z.number().optional(),"divide":z.number().optional()}),z.number()]).optional(),"created_at":z.union([z.object({}),z.string().datetime(),z.string()]).optional(),"updated_at":z.union([z.object({}),z.string().datetime(),z.string()]).optional(),"modified_by_user_id":z.union([z.object({}),z.string()]).optional(),"organization":z.object({}).optional(),"redirect_urls":z.object({}).optional(),"branding":z.object({}).optional(),"app_role":z.object({}).optional(),"app_role_assignment":z.object({}).optional(),"AuthRequest":z.object({}).optional(),"session":z.object({}).optional(),"user_access_controls":z.object({}).optional(),"authentication_rule":z.object({}).optional()}).optional(),"query":z.object({"id":z.any().optional(),"org_id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"app/orgs/:org_id/branding":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"logo":z.string().optional(),"primary_color":z.string().optional(),"secondary_color":z.string().optional(),"font":z.string().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PUT":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional()}).optional(),"body":z.object({"url":z.string().optional(),"created_at":z.union([z.string().datetime(),z.string()]).optional(),"updated_at":z.union([z.string().datetime(),z.string()]).optional(),"modified_by_user_id":z.string().optional()}).optional(),"query":z.object({"app_id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"logo":z.string().optional(),"primary_color":z.string().optional(),"secondary_color":z.string().optional(),"font":z.string().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"DELETE":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional(),"app_id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional(),"app_id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"api/siws/message/:app_id/:public_key/generate":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"app_id":z.string().optional(),"public_key":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"siws":z.any().optional(),"legacy":z.string().optional()}).optional()}).optional()}).optional()}).optional(),"app/orgs/:org_id/apps/:app_id/access_control":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.array(z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"application_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"account_id":z.string().optional(),"access_type":z.enum(["BLACKLIST","WHITELIST"]).optional(),"modified_by_user_id":z.string().optional()})).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PUT":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"created_at":z.union([z.string().datetime(),z.string()]).optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"account_id":z.string().optional(),"access_type":z.enum(["BLACKLIST","WHITELIST"]).optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"application_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"account_id":z.string().optional(),"access_type":z.enum(["BLACKLIST","WHITELIST"]).optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"DELETE":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"application_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"account_id":z.string().optional(),"access_type":z.enum(["BLACKLIST","WHITELIST"]).optional(),"modified_by_user_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"application_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"account_id":z.string().optional(),"access_type":z.enum(["BLACKLIST","WHITELIST"]).optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"app/orgs/:org_id/apps/:app_id/app_roles":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.array(z.object({"id":z.number().optional(),"name":z.string().optional(),"application_id":z.string().optional(),"created_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()})).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PUT":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"name":z.string().optional(),"created_at":z.union([z.string().datetime(),z.string()]).optional(),"updated_at":z.union([z.string().datetime(),z.string()]).optional(),"modified_by_user_id":z.string().optional(),"app_role_assignment":z.object({}).optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"name":z.string().optional(),"application_id":z.string().optional(),"created_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"DELETE":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"id":z.number().optional(),"name":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"app/orgs/:org_id/apps/:app_id/auth_rules":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.array(z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"application_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"is_required":z.boolean().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()})).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PUT":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"created_at":z.union([z.string().datetime(),z.string()]).optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"is_required":z.boolean().optional(),"updated_at":z.union([z.string().datetime(),z.string()]).optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"application_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"is_required":z.boolean().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"DELETE":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"application_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"is_required":z.boolean().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"created_at":z.string().datetime().optional(),"application_id":z.string().optional(),"provider":z.enum(["DISCORD","GITHUB","IP_ADDRESS","SOLANA","TWITTER"]).optional(),"is_required":z.boolean().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"app/orgs/:org_id/apps/:app_id/redirects":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.array(z.object({"id":z.number().optional(),"url":z.string().optional(),"application_id":z.string().optional(),"created_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()})).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PUT":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"url":z.string().optional(),"created_at":z.union([z.string().datetime(),z.string()]).optional(),"updated_at":z.union([z.string().datetime(),z.string()]).optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional(),"url":z.string().optional(),"application_id":z.string().optional(),"created_at":z.string().datetime().optional(),"updated_at":z.string().datetime().optional(),"modified_by_user_id":z.string().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"DELETE":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"id":z.number().optional(),"url":z.string().optional()}).optional(),"query":z.object({"id":z.any().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"id":z.number().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional(),"app/orgs/:org_id/apps/:app_id/secrets":z.object({"GET":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"access_token_secret":z.string().optional(),"refresh_token_secret":z.string().optional()}).optional()}).optional(),"errors":z.object({"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional(),"PATCH":z.object({"parameters":z.object({"path":z.object({"org_id":z.string().optional(),"app_id":z.string().optional()}).optional(),"body":z.object({"refresh_token_secret":z.boolean().optional(),"access_token_secret":z.boolean().optional()}).optional()}).optional(),"responses":z.object({"200":z.object({"access_token_secret":z.string().optional(),"refresh_token_secret":z.string().optional()}).optional()}).optional(),"errors":z.object({"400":z.object({"message":z.literal("Missing user id").optional()}).optional(),"401":z.object({"message":z.literal("Unauthorized").optional()}).optional()}).optional()}).optional()}).optional()});